# DesignPattern
整理23种设计模式设计原理，使用场景，以及实现方式和实战

 **责任链模式**
 
 ![这里写图片描述](http://img.blog.csdn.net/20170919161341675?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmlnaHRjdXJ0aXM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

> - 定义1：   是行为型设计模式之一 。 什么是" 链 "?   我们将多个节点首尾相连所构成的模型称为链，比如生活中的锁链，就是由一个个圆角长方形的铁环串起来的结构。 对于链式结构，每个节点可以被拆开再连接，因此，链式结构也具有很好的灵活性。将这样的一种结构应用于编程领域，   将一个节点看成一个对象，每一个对象都拥有不同的处理逻辑，将一个请求从链式的首端发出，沿着链的路径依次传递到每一个节点对象，直到有对象处理这个请求为止。
> 
> -  定义2：   使多个对象都有机会处理请求，从而避免了请求的发起者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。

  优势：
    1.请求的发起可以从节点的任何一个节点开始，同时也可以改变内部的传递规则，比如Test2中，主管不在，可以直接上报给经理（指定小组长的下一个节点为经理）。
    2.解除了处理对象和请求者对象的耦合，可以灵活的增加和减少处理节点
    
   不足：
    责任链模式的不足在于对链中请求处理者的遍历，如果处理者太多那么遍历必定会影响性能，特别是在一些递归调用中，要慎重。

   注意事项：
 1. 对于责任链中的一个处理者对象，其只有两个行为，一是处理请求，二是将请求转送到下一个节点，不允许某个处理者对象在处理了请求后又将请求转送给上一个节点的情况
 2. 对于一条责任链模式来说，一个请求最终只有两种情况，一是被某个对象所处理，另一个就是所有的对象均未对其处理，对于前一种情况我们称该责任链模式为纯的责任链模式，对于后一种情况我们称为不纯的责任链模式

----------
  **单例模式**
>  定义：
    确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例

  使用场景：
     确保某个类有且只有一个对象的场景，避免产生多个对象消耗过多的资源，或者某种类型的对象只应该有且只有一个。
    例如,创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源。


  构建单例类的4个关键点：
  1.构造函数不对外开放，一般为private
  2.通过一个静态方法或者枚举返回单例类的实例
  3.保证单例类的对象有且只有一个，尤其是在多线程的情况下
  4.确保单例类的对象在反序列化的时候不会重新构造对象

----------

   **Builder模式**
>    Builder模式是一步一步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构建流程。
    该模式是为了将构建复杂对象的过程和它的部件解耦，使得构建过程和部件完全隔离开来。
    因为一个复杂的对象有很多的组件部分，如汽车，有车轮，方向盘，发动机，还有各种小零件，如何将这些部件装配成一辆汽车，这个装配过程很漫长，也很复杂。
    对于这种情况，为了构建过程中对外隐藏实现细节，就可以使用Builder模式将部件和组装过程分离，使得构建过程和部件都可以自由扩展，两者之间的耦合也降到了最低。

  定义：
    将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。

   使用场景:
    1.相同的方法，不同的执行顺序，产生不同的事件结果时。
    2.多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同
    3.产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用。
    4.当初始化一个对象特别复杂，如参数多，且参数都有默认值时。

   优点：
    1.良好的封装性，使用构造者模式可以使客户端不必知道产品构建的细节
    2.构建者独立，容易扩展
   
  缺点：
    会产生多余的Builder对象以及Director对象，消耗内存
    


----------
 **代理模式：、**
 >   代理模式，也叫委托模式
   何为代理模式，通过代理服务器上网是一种代理模式，请别人买饭也是一种代理模式。

  定义：
    为其他对象提供一种代理以控制对这个对象的访问

  使用场景：
     当无法或者不想直接访问某个对象或访问某个对象存在困难的时候可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口。


 实战：
     静态代理目前实际使用的场景是，一个类的使用特别复杂，不想直接使用它的时候,并暴露它的结构的时候。可以为它添加一个静态代理类。
 动态代理：可以动态的给一些对象添加代理类，添加一些公共的逻辑（比如数据库的开启事物和关闭事物）

